{% comment %}
Hero Demo: Uses original hero-prototype code with horizontal layout
Layout: List (left) | Metronome (right) | Headline (below)
Original code from hero-prototype/metronome.js and hero-prototype/styles.css
{% endcomment %}

<div class="hero-demo-wrapper">
  <style>
    /* Reset for hero wrapper */
    .hero-demo-wrapper * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --night-bg: #000000;
      --accent: #f97316;
      --text-primary: #e8e6e3;
      --text-muted: #6b7280;
      --check-complete: #22c55e;

      /* Checklist scaling - smaller to balance focal metronome */
      --item-height: 40px;
      --visible-items: 7;
      --checklist-width: clamp(260px, 35vw, 360px);
    }

    .hero-demo-wrapper {
      all: unset;
      display: block;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: var(--night-bg);
      color: var(--text-primary);
      overflow: visible;
    }

    .hero {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      padding: 2.5rem 0 2rem;
    }

    @media (max-width: 900px) {
      .hero {
        padding: 1.5rem 0 1.5rem;
      }
    }

    @media (max-width: 600px) {
      .hero {
        padding: 0.75rem 0 1rem;
      }
    }

    .background {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--night-bg);
      z-index: 0;
    }

    .hero-noise {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: -400px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 0.6rem;
      line-height: 1.6;
      color: rgba(255, 255, 255, 0.06);
      padding: 0.5rem;
      user-select: none;
      pointer-events: none;
      word-break: break-word;
      z-index: 0;
    }

    .hero-noise .phrase {
      transition: color 0.8s ease-in-out;
      display: inline;
    }

    .hero-noise .phrase.highlight {
      color: rgba(255, 255, 255, 0.18);
    }

    .hero-noise.flash .phrase {
      color: rgba(255, 255, 255, 0.5) !important;
      transition: color 0.2s ease-out;
      animation: phrase-shake 0.12s ease-in-out infinite;
    }

    .hero-noise.flash .phrase:nth-child(odd) {
      animation-delay: 0.04s;
    }

    .hero-noise.flash .phrase:nth-child(3n) {
      animation-delay: 0.08s;
    }

    @keyframes phrase-shake {
      0%, 100% { transform: translate(0, 0); }
      25% { transform: translate(-2px, 1px); }
      50% { transform: translate(2px, -1px); }
      75% { transform: translate(-1px, -2px); }
    }

    .hero-noise.post-flash .phrase {
      color: rgba(255, 255, 255, 0.25);
      transition: color 0.3s ease-out;
    }

    .hero-noise .phrase.fade-out {
      color: rgba(255, 255, 255, 0) !important;
      transition: color 1s ease-out;
      animation: none !important;
    }

    .spotlight {
      position: absolute;
      top: 55%;
      left: 50%;
      width: 450px;
      height: 450px;
      transform: translate(-50%, -50%);
      background: radial-gradient(
        circle at center,
        rgba(255, 255, 255, 0.24) 0%,
        rgba(255, 255, 255, 0.16) 10%,
        rgba(255, 255, 255, 0.08) 25%,
        rgba(255, 255, 255, 0) 45%
      );
      z-index: 0;
      pointer-events: none;
      transition: opacity 2s ease-out;
    }

    .content {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.25rem;
      padding: 0.5rem 1rem;
      width: 100%;
      max-width: 100vw;
    }

    /* Hero row - always horizontal, scales down on smaller screens */
    .hero-row {
      display: flex;
      align-items: center;
      justify-content: center;
      transform-origin: center center;
    }

    /* Stage: horizontal layout - list left, metronome right */
    .stage {
      all: unset;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: clamp(1.5rem, 4vw, 3rem);
      flex-shrink: 0;
    }

    /* Scale down at medium screens */
    @media (max-width: 900px) {
      .hero-row {
        transform: scale(0.85);
      }
    }

    /* Scale down more at small screens */
    @media (max-width: 700px) {
      .hero-row {
        transform: scale(0.7);
      }
    }

    /* Scale down further at very small screens */
    @media (max-width: 500px) {
      .hero-row {
        transform: scale(0.55);
      }
    }

    /* Metronome Container - focal point, tight fit */
    .metronome-container {
      position: relative;
      width: 280px;
      height: 340px;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      flex-shrink: 0;
      overflow: visible;
      padding-bottom: 24px;
    }

    .tick-area {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .tick-indicator {
      position: absolute;
      font-size: 0.7rem;
      font-weight: 500;
      color: rgba(107, 114, 128, 0.6);
      letter-spacing: 0.05em;
      pointer-events: none;
      opacity: 0;
      animation: tick-fade 150ms linear forwards;
    }

    @keyframes tick-fade {
      0% { opacity: 0.5; }
      100% { opacity: 0; }
    }

    .time-indicator {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.75rem;
      font-weight: 400;
      color: rgba(107, 114, 128, 0.5);
      letter-spacing: 0.08em;
      font-variant-numeric: tabular-nums;
      transition: opacity 2s ease-out;
    }

    .time-indicator.fading {
      opacity: 0;
    }

    .time-indicator.calm {
      font-weight: 500;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      color: rgba(232, 230, 227, 0.6);
      opacity: 1;
      transition: opacity 2s ease-in;
    }

    /* Metronome - fills container tightly */
    .metronome {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 260px;
      height: 300px;
    }

    .metronome-arm-container {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 260px;
      height: 260px;
      z-index: 2;
      overflow: visible;
    }

    .metronome-arm {
      position: absolute;
      bottom: 24px;
      left: 50%;
      width: 5px;
      height: 175px;
      background: linear-gradient(180deg, var(--accent) 0%, #c2410c 100%);
      transform-origin: bottom center;
      transform: translateX(-50%) rotate(0deg);
    }

    .metronome-weight {
      position: absolute;
      top: 24px;
      left: 50%;
      transform: translateX(-50%);
      width: 30px;
      height: 20px;
      background: var(--accent);
      border-radius: 2px;
    }

    .metronome-pivot {
      position: absolute;
      bottom: 18px;
      left: 50%;
      transform: translateX(-50%);
      width: 14px;
      height: 14px;
      background: #444;
      border-radius: 50%;
      border: 2px solid var(--accent);
      z-index: 3;
    }

    .metronome-body {
      position: absolute;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      width: 88px;
      height: 230px;
      background: linear-gradient(180deg, #2a2a2a 0%, #1a1a1a 100%);
      clip-path: polygon(25% 0%, 75% 0%, 100% 100%, 0% 100%);
      z-index: 1;
    }

    .metronome-scale {
      position: absolute;
      top: 24px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
    }

    .scale-mark {
      width: 2px;
      height: 9px;
      background: var(--text-muted);
    }

    .scale-mark:nth-child(3) {
      height: 15px;
      background: var(--accent);
    }

    .metronome-base {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 125px;
      height: 24px;
      background: linear-gradient(180deg, #333 0%, #1a1a1a 100%);
      border-radius: 0 0 4px 4px;
      z-index: 1;
    }

    /* Headline */
    .headline {
      all: unset;
      display: block;
      text-align: center;
      font-size: clamp(1.1rem, 4.5vw, 3.4rem);
      font-weight: 700;
      letter-spacing: -0.02em;
      line-height: 1.15;
      margin: 0;
      padding: 0;
    }

    .headline-static {
      color: var(--text-primary);
      white-space: nowrap;
    }

    .headline-pulse {
      color: var(--accent);
      display: inline-block;
    }

    .headline-reveal {
      color: var(--accent);
      opacity: 0;
      transition: opacity 1.5s ease-in;
    }

    .headline-reveal.visible {
      opacity: 1;
    }

    .hero-subtext {
      position: relative;
      font-size: clamp(0.9rem, 2.5vw, 1.3rem);
      font-weight: 700;
      color: rgba(255, 255, 255, 0.08);
      background: transparent;
      text-align: center;
      margin: 1.25rem 0 0;
      padding: 0.7rem 2rem;
      line-height: 1.4;
      letter-spacing: 0.02em;
      white-space: nowrap;
      transition: font-size 0.6s ease-out, padding 0.6s ease-out, background 0.3s ease-out;
    }

    .hero-subtext.expanded {
      font-size: clamp(1.25rem, 4vw, 2rem);
      padding: 1rem 3rem;
      color: #000;
      background: linear-gradient(90deg, transparent 0%, #d4a510 8%, #d4a510 92%, transparent 100%);
      animation: subtext-shake 0.4s ease-out;
    }

    @keyframes subtext-shake {
      0%, 100% { transform: translateX(0); }
      15% { transform: translateX(-4px); }
      30% { transform: translateX(4px); }
      45% { transform: translateX(-3px); }
      60% { transform: translateX(3px); }
      75% { transform: translateX(-2px); }
      90% { transform: translateX(2px); }
    }

    .hero-subtext strong {
      font-weight: inherit;
      transition: font-weight 0.3s ease-out;
    }

    .hero-subtext.expanded strong {
      font-weight: 800;
    }

    .chaos-word {
      display: inline-block;
      animation:
        chaos-shake-wild 2.4s linear infinite,
        chaos-color 4s ease-in-out infinite;
    }

    .hero-subtext.expanded .chaos-word {
      animation:
        chaos-shake-tame 8s linear infinite,
        chaos-color-subtle 5s ease-in-out infinite;
    }

    @keyframes chaos-shake-wild {
      0% { transform: translateX(0) translateY(0) rotate(0deg); }
      8% { transform: translateX(-4px) translateY(2px) rotate(-1.5deg); }
      16% { transform: translateX(3px) translateY(-3px) rotate(1deg); }
      24% { transform: translateX(-2px) translateY(4px) rotate(-0.8deg); }
      32% { transform: translateX(4px) translateY(1px) rotate(1.2deg); }
      40% { transform: translateX(-3px) translateY(-2px) rotate(-1deg); }
      48% { transform: translateX(2px) translateY(3px) rotate(0.7deg); }
      56% { transform: translateX(-4px) translateY(-1px) rotate(-1.3deg); }
      64% { transform: translateX(1px) translateY(3px) rotate(1.5deg); }
      72% { transform: translateX(-2px) translateY(-4px) rotate(-0.6deg); }
      80% { transform: translateX(3px) translateY(2px) rotate(0.9deg); }
      88% { transform: translateX(-1px) translateY(-2px) rotate(-1.1deg); }
      100% { transform: translateX(0) translateY(0) rotate(0deg); }
    }

    @keyframes chaos-shake-tame {
      0% { transform: translateX(0) translateY(0) rotate(0deg); }
      10% { transform: translateX(-3px) translateY(1.5px) rotate(-1deg); }
      20% { transform: translateX(2.5px) translateY(-2px) rotate(0.8deg); }
      30% { transform: translateX(-1.5px) translateY(3px) rotate(-0.6deg); }
      40% { transform: translateX(3px) translateY(1px) rotate(1deg); }
      50% { transform: translateX(-2.5px) translateY(-2px) rotate(-0.8deg); }
      60% { transform: translateX(2px) translateY(2.5px) rotate(0.5deg); }
      70% { transform: translateX(-3px) translateY(-1.5px) rotate(-0.9deg); }
      80% { transform: translateX(1.5px) translateY(2px) rotate(1deg); }
      90% { transform: translateX(-2px) translateY(-2.5px) rotate(-0.5deg); }
      100% { transform: translateX(0) translateY(0) rotate(0deg); }
    }

    @keyframes chaos-scale {
      0%, 100% { font-size: 1em; }
      33% { font-size: 1.05em; }
      66% { font-size: 0.97em; }
    }

    @keyframes chaos-color {
      0%, 100% {
        color: rgba(180, 60, 60, 0.7);
        text-shadow: 0 0 4px rgba(180, 60, 60, 0.2);
      }
      25% {
        color: rgba(140, 30, 30, 0.75);
        text-shadow: 0 0 2px rgba(140, 30, 30, 0.15);
      }
      50% {
        color: rgba(160, 50, 50, 0.65);
        text-shadow: 0 0 5px rgba(160, 50, 50, 0.25);
      }
      75% {
        color: rgba(100, 25, 25, 0.8);
        text-shadow: 0 0 2px rgba(100, 25, 25, 0.1);
      }
    }

    @keyframes chaos-color-subtle {
      0%, 100% {
        color: rgba(50, 50, 50, 1);
        text-shadow: 0 0 3px rgba(185, 28, 28, 0.2);
      }
      50% {
        color: rgba(80, 20, 20, 1);
        text-shadow: 0 0 4px rgba(127, 29, 29, 0.25);
      }
    }



    /* Checklist Viewport */
    .checklist-viewport {
      position: relative;
      width: var(--checklist-width);
      max-width: 100%;
      height: calc(var(--item-height) * var(--visible-items));
      overflow: hidden;
      border-radius: 8px;
      background: #000;
      border: 1px solid rgba(255, 255, 255, 0.06);
      flex-shrink: 0;
    }

    .checklist-track {
      all: unset;
      display: block;
      list-style: none;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      margin: 0;
      padding: 0;
    }

    .checklist-item {
      all: unset;
      display: flex;
      align-items: center;
      box-sizing: border-box;
      gap: 0.75rem;
      padding: 0 1rem;
      height: var(--item-height);
      border-bottom: 1px solid rgba(255, 255, 255, 0.04);
      margin: 0;
    }

    .check-box {
      width: 18px;
      height: 18px;
      position: relative;
      flex-shrink: 0;
    }

    .check-box::before {
      content: "";
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 80%;
      height: 80%;
      border-radius: 3px;
      border: 2px solid currentColor;
      opacity: 0.4;
    }

    .check-text {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace !important;
      font-size: 11px; /* JS will override based on longest item */
      line-height: 1.3;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .checklist-item {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace !important;
    }

    .typing-cursor {
      display: inline-block;
      width: 2px;
      height: 1em;
      background: rgba(249, 115, 22, 0.9);
      margin-left: 1px;
      vertical-align: text-bottom;
      animation: cursor-blink 0.4s ease-in-out infinite;
    }

    @keyframes cursor-blink {
      0%, 100% { opacity: 0.9; }
      50% { opacity: 0.4; }
    }

    .check-svg {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 24px;
      height: 24px;
      opacity: 0;
      pointer-events: none;
      overflow: visible;
    }

    .check-path-down {
      fill: none;
      stroke: var(--check-complete);
      stroke-width: 5;
      stroke-linecap: round;
      stroke-linejoin: round;
      stroke-dasharray: 10;
      stroke-dashoffset: 10;
    }

    .check-path-up {
      fill: none;
      stroke: var(--check-complete);
      stroke-width: 4;
      stroke-linecap: round;
      stroke-linejoin: round;
      stroke-dasharray: 20;
      stroke-dashoffset: 20;
    }

    .checklist-item.drawing .check-box::before {
      display: none;
    }

    .checklist-item.drawing .check-svg {
      opacity: 1;
    }

    .checklist-item.drawing .check-path-down {
      animation: draw-down calc(var(--check-duration, 255ms) * 0.30) cubic-bezier(0.4, 0, 0.6, 1) forwards;
    }

    .checklist-item.drawing .check-path-up {
      animation: draw-up calc(var(--check-duration, 255ms) * 0.70) cubic-bezier(0.2, 0, 0.4, 1) forwards;
      animation-delay: calc(var(--check-duration, 255ms) * 0.30);
    }

    @keyframes draw-down {
      to {
        stroke-dashoffset: 0;
      }
    }

    @keyframes draw-up {
      to {
        stroke-dashoffset: 0;
      }
    }

    .checklist-item.completed .check-box::before {
      display: none;
    }

    .checklist-item.completed .check-svg {
      opacity: 1;
    }

    .checklist-item.completed .check-path-down,
    .checklist-item.completed .check-path-up {
      stroke-dashoffset: 0;
    }

  </style>

  <div class="hero">
    <div class="background"></div>
    <div class="hero-noise" aria-hidden="true"><span class="hero-noise-text"></span></div>
    <div class="content">
      <div class="hero-row">
        <div class="stage">
          <!-- Checklist (left) -->
          <div class="checklist-viewport">
          <ul class="checklist-track">
            <!-- Items created by JS -->
          </ul>
        </div>

        <!-- Metronome (right) -->
        <div class="metronome-container">
          <div class="spotlight"></div>
          <div class="tick-area"></div>
          <div class="metronome">
            <div class="metronome-arm-container">
              <div class="metronome-arm">
                <div class="metronome-weight"></div>
              </div>
              <div class="metronome-pivot"></div>
            </div>
            <div class="metronome-body">
              <div class="metronome-scale">
                <div class="scale-mark"></div>
                <div class="scale-mark"></div>
                <div class="scale-mark"></div>
                <div class="scale-mark"></div>
                <div class="scale-mark"></div>
              </div>
            </div>
            <div class="metronome-base"></div>
          </div>
          <div class="time-indicator">10:00 PM</div>
        </div>
        </div>
      </div>

      <!-- Headline (below) -->
      <h1 class="headline">
        <span class="headline-static">Systems should be Boring.</span><br>
        <span class="headline-pulse headline-reveal" id="headline-reveal">On Purpose.</span>
      </h1>
      <p class="hero-subtext"><strong>We</strong> calm <span class="chaos-word">chaos</span>. <strong>You</strong> ship product.</p>
    </div>
  </div>

  <!-- Checklist items from Jekyll data -->
  <script>
    var CHECKLIST_ITEMS = [
      {% for item in site.data.checklist.items %}"{{ item }}"{% unless forloop.last %},{% endunless %}
      {% endfor %}
    ];
  </script>

  <!-- Original metronome.js from hero-prototype (adapted for orange accent) -->
  <script>
/**
 * Metronome Hero Prototype
 *
 * State Flow:
 * 1. requestAnimationFrame loop runs continuously
 * 2. Phase accumulates based on elapsed time (determines hammer angle)
 * 3. Hammer angle derived from phase every frame: angle = sin(phase) * maxAngle
 * 4. Tick emitted when phase crosses PI (hammer crosses center)
 * 5. Tick listeners advance list position only
 * 6. Animation loop updates all visual styles every frame
 * 7. Clock updates asynchronously, decoupled from ticks
 *
 * Checklist Mechanics:
 * - Arbitrary item count, 7 visible at once
 * - Center item (index 3 in viewport) is the active item
 * - On tick: center item completes, scrollOffset target advances
 * - Animation loop interpolates scrollOffset and derives all visual styles
 * - Brightness/color derived mathematically from pixel distance to center
 *
 * Clock Mechanics:
 * - Updates every 5-9 ticks
 * - Update is scheduled with 500-1200ms delay
 * - Never updates inside tick handler
 * - Represents time passing, not metronome beat
 */

(function() {
  'use strict';

  // Timing constants
  var TICK_INTERVAL_MS = 1200;
  var TICKS_PER_SECOND = 1000 / TICK_INTERVAL_MS;
  var PHASE_SPEED = Math.PI * TICKS_PER_SECOND;

  // Metronome constants
  var MAX_ANGLE = 30;

  // Checklist constants
  var ITEM_HEIGHT = 40;
  var VISIBLE_ITEMS = 7;
  var CENTER_INDEX = Math.floor(VISIBLE_ITEMS / 2); // 3 for 7 visible items

  // Checkmark animation constants
  var CHECK_DRAW_DURATION_MS = 255;
  var CHECK_BUFFER_BEFORE_TICK_MS = 300;
  var CHECK_TOTAL_LEAD_MS = CHECK_DRAW_DURATION_MS + CHECK_BUFFER_BEFORE_TICK_MS;
  var CHECK_START_PHASE_OFFSET = (CHECK_TOTAL_LEAD_MS / TICK_INTERVAL_MS) * Math.PI;

  // Derived constants
  var TOTAL_ITEMS = CHECKLIST_ITEMS.length;
  var SCROLL_SPEED = 320;

  var INITIAL_SCROLL_OFFSET = -CENTER_INDEX * ITEM_HEIGHT;

  // Colors (orange accent)
  var COLOR_ACCENT = { r: 250, g: 204, b: 21 };       // #facc15 yellow
  var COLOR_COMPLETED = { r: 180, g: 180, b: 175 };
  var COLOR_FUTURE = { r: 90, g: 95, b: 105 };

  // Tick indicator constants (scaled for larger 340px container)
  var TICK_RADIUS_MIN = 95;
  var TICK_RADIUS_MAX = 120;
  var TICK_LIFETIME_MS = 150;

  var TICK_ANGLE_RANGES = [
    { min: Math.PI * 0.55, max: Math.PI * 0.75 },
    { min: Math.PI * 0.25, max: Math.PI * 0.45 }
  ];

  // Clock constants
  var START_HOUR = 22;
  var START_MINUTE = 0;
  var TOTAL_MINUTES = 600;
  var CLOCK_UPDATE_TICK_MIN = 3;
  var CLOCK_UPDATE_TICK_MAX = 10;
  var CLOCK_DELAY_MIN = 500;
  var CLOCK_DELAY_MAX = 1200;

  // CALM transition constants
  var CALM_DELAY_MS = 12000;
  var CALM_FADE_DURATION_MS = 2000;

  // Reveal delay for "On Purpose."
  var REVEAL_DELAY_MS = 1000;

  // State
  var phase = 0;
  var lastTickPhase = 0;
  var lastFrameTime = null;
  var tickCount = 0;

  // Silhouette state - progresses with checklist completion
  var silhouetteProgress = 0;
  var SILHOUETTE_COLOR = { r: 22, g: 23, b: 28 };

  // Orange metronome colors for silhouette transition
  var ARM_COLOR_START = { r: 249, g: 115, b: 22 };
  var ARM_COLOR_END = { r: 194, g: 65, b: 12 };
  var WEIGHT_COLOR = { r: 249, g: 115, b: 22 };
  var PIVOT_BG_COLOR = { r: 68, g: 68, b: 68 };
  var PIVOT_BORDER_COLOR = { r: 249, g: 115, b: 22 };
  var BODY_COLOR_START = { r: 42, g: 42, b: 42 };
  var BODY_COLOR_END = { r: 26, g: 26, b: 26 };
  var BASE_COLOR_START = { r: 51, g: 51, b: 51 };
  var BASE_COLOR_END = { r: 26, g: 26, b: 26 };

  // Scroll state
  var currentScrollOffset = INITIAL_SCROLL_OFFSET;
  var targetScrollOffset = INITIAL_SCROLL_OFFSET;

  var activeIndex = 0;
  var drawingIndex = -1;

  // Typewriter state
  var typingIndex = -1;
  var TYPING_DURATION_MS = 250;

  // Clock state
  var ticksSinceLastClockUpdate = 0;
  var nextClockUpdateThreshold = randomInt(CLOCK_UPDATE_TICK_MIN, CLOCK_UPDATE_TICK_MAX);
  var clockCompletedCount = 0;
  var isComplete = false;

  // DOM References
  var arm, armWeight, armPivot, metronomeBody, metronomeBase, metronomeScale, scaleMarks, headlinePulse, checklistTrack, checklistItemElements, background, spotlight, tickArea, timeIndicator, headlineReveal;

  function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function emitTick() {
    document.dispatchEvent(new CustomEvent('metronome-tick', {
      detail: { tickCount: tickCount }
    }));
  }

  function lerp(a, b, t) {
    return a + (b - a) * t;
  }

  function lerpColor(colorA, colorB, t) {
    return {
      r: Math.round(lerp(colorA.r, colorB.r, t)),
      g: Math.round(lerp(colorA.g, colorB.g, t)),
      b: Math.round(lerp(colorA.b, colorB.b, t))
    };
  }

  function colorToRgb(color) {
    return 'rgb(' + color.r + ',' + color.g + ',' + color.b + ')';
  }

  function calculateVisualProperties(itemPixel, centerPixel, isCompleted) {
    var distance = Math.abs(itemPixel - centerPixel);
    var maxDistance = CENTER_INDEX * ITEM_HEIGHT;
    var isAboveCenter = itemPixel < centerPixel;
    var isBelowCenter = itemPixel > centerPixel;

    var normalizedDistance = Math.min(distance / maxDistance, 1);
    var curvedDistance = normalizedDistance * normalizedDistance;

    var opacity;
    if (isAboveCenter) {
      opacity = 1 - curvedDistance * 0.6;
    } else if (isBelowCenter) {
      opacity = 1 - curvedDistance * 0.8;
    } else {
      opacity = 1;
    }
    opacity = Math.max(0.2, opacity);

    var color, fontWeight;

    if (normalizedDistance < 0.1) {
      color = COLOR_ACCENT;
      fontWeight = 700;
    } else if (isAboveCenter || isCompleted) {
      color = lerpColor(COLOR_COMPLETED, { r: 140, g: 145, b: 150 }, curvedDistance);
      fontWeight = 400;
    } else {
      color = lerpColor(COLOR_FUTURE, { r: 60, g: 65, b: 75 }, curvedDistance);
      fontWeight = 400;
    }

    return {
      opacity: opacity,
      color: color,
      fontWeight: fontWeight
    };
  }

  function updateVisuals() {
    var centerPixel = CENTER_INDEX * ITEM_HEIGHT + ITEM_HEIGHT / 2;

    for (var i = 0; i < TOTAL_ITEMS; i++) {
      var item = checklistItemElements[i];
      var itemTopInViewport = i * ITEM_HEIGHT - currentScrollOffset;
      var itemCenterInViewport = itemTopInViewport + ITEM_HEIGHT / 2;

      if (itemTopInViewport > -ITEM_HEIGHT && itemTopInViewport < VISIBLE_ITEMS * ITEM_HEIGHT + ITEM_HEIGHT) {
        var isItemCompleted = item.classList.contains('completed');
        var props = calculateVisualProperties(itemCenterInViewport, centerPixel, isItemCompleted);

        item.style.opacity = props.opacity;
        item.style.color = colorToRgb(props.color);
        item.style.fontWeight = props.fontWeight;
        item.style.textDecoration = 'none';
      }
    }
  }

  function animationLoop(currentTime) {
    if (lastFrameTime === null) {
      lastFrameTime = currentTime;
    }

    var deltaTime = (currentTime - lastFrameTime) / 1000;
    lastFrameTime = currentTime;

    phase += deltaTime * PHASE_SPEED;

    var angle = Math.sin(phase) * MAX_ANGLE;
    arm.style.transform = 'translateX(-50%) rotate(' + angle + 'deg)';

    // Apply silhouette effect based on checklist progress
    if (silhouetteProgress > 0) {
      var armTop = lerpColor(ARM_COLOR_START, SILHOUETTE_COLOR, silhouetteProgress);
      var armBottom = lerpColor(ARM_COLOR_END, SILHOUETTE_COLOR, silhouetteProgress);
      arm.style.background = 'linear-gradient(180deg, ' + colorToRgb(armTop) + ' 0%, ' + colorToRgb(armBottom) + ' 100%)';
      arm.style.opacity = 1 - silhouetteProgress * 0.15;

      var weightColor = lerpColor(WEIGHT_COLOR, SILHOUETTE_COLOR, silhouetteProgress);
      armWeight.style.background = colorToRgb(weightColor);

      var pivotBg = lerpColor(PIVOT_BG_COLOR, SILHOUETTE_COLOR, silhouetteProgress);
      var pivotBorder = lerpColor(PIVOT_BORDER_COLOR, SILHOUETTE_COLOR, silhouetteProgress);
      armPivot.style.background = colorToRgb(pivotBg);
      armPivot.style.borderColor = colorToRgb(pivotBorder);

      var bodyTop = lerpColor(BODY_COLOR_START, SILHOUETTE_COLOR, silhouetteProgress);
      var bodyBottom = lerpColor(BODY_COLOR_END, SILHOUETTE_COLOR, silhouetteProgress);
      metronomeBody.style.background = 'linear-gradient(180deg, ' + colorToRgb(bodyTop) + ' 0%, ' + colorToRgb(bodyBottom) + ' 100%)';

      var baseTop = lerpColor(BASE_COLOR_START, SILHOUETTE_COLOR, silhouetteProgress);
      var baseBottom = lerpColor(BASE_COLOR_END, SILHOUETTE_COLOR, silhouetteProgress);
      metronomeBase.style.background = 'linear-gradient(180deg, ' + colorToRgb(baseTop) + ' 0%, ' + colorToRgb(baseBottom) + ' 100%)';

      var centerMarkColor = lerpColor({ r: 249, g: 115, b: 22 }, { r: 50, g: 52, b: 58 }, silhouetteProgress);
      for (var i = 0; i < scaleMarks.length; i++) {
        if (i === 2) {
          scaleMarks[i].style.opacity = 1 - silhouetteProgress * 0.65;
          scaleMarks[i].style.background = colorToRgb(centerMarkColor);
        } else {
          scaleMarks[i].style.opacity = 1 - silhouetteProgress;
        }
      }
    }

    if (shouldStartDrawing() && activeIndex < TOTAL_ITEMS) {
      startCheckmarkDrawing(activeIndex);
    }

    var currentTickNumber = Math.floor(phase / Math.PI);
    var lastTickNumber = Math.floor(lastTickPhase / Math.PI);

    if (currentTickNumber > lastTickNumber) {
      tickCount++;
      emitTick();
      spawnTickIndicator();
      scheduleClockUpdateIfNeeded();
    }
    lastTickPhase = phase;

    if (currentScrollOffset < targetScrollOffset) {
      currentScrollOffset += SCROLL_SPEED * deltaTime;
      if (currentScrollOffset > targetScrollOffset) {
        currentScrollOffset = targetScrollOffset;
      }
      checklistTrack.style.transform = 'translateY(' + (-currentScrollOffset) + 'px)';
    }

    updateVisuals();
    updateHeadlineBrightness();

    requestAnimationFrame(animationLoop);
  }

  function spawnTickIndicator() {
    var range = TICK_ANGLE_RANGES[Math.floor(Math.random() * TICK_ANGLE_RANGES.length)];
    var angle = range.min + Math.random() * (range.max - range.min);

    var containerRect = tickArea.getBoundingClientRect();
    var containerSize = containerRect.width;
    var scale = containerSize / 280;

    var radius = (TICK_RADIUS_MIN + Math.random() * (TICK_RADIUS_MAX - TICK_RADIUS_MIN)) * scale;

    var centerX = containerSize / 2;
    var centerY = containerSize / 2;

    var x = centerX + Math.cos(angle) * radius;
    var y = centerY - Math.sin(angle) * radius;

    var tick = document.createElement('span');
    tick.className = 'tick-indicator';
    tick.textContent = 'tick';
    tick.style.left = x + 'px';
    tick.style.top = y + 'px';
    tick.style.transform = 'translate(-50%, -50%)';

    tickArea.appendChild(tick);

    setTimeout(function() {
      if (tick.parentNode) {
        tick.parentNode.removeChild(tick);
      }
    }, TICK_LIFETIME_MS);
  }

  function updateHeadlineBrightness() {
    var deflection = Math.abs(Math.sin(phase));
    var brightness = 1.0 + (1 - deflection) * 0.12;
    headlinePulse.style.filter = 'brightness(' + brightness + ')';
  }

  function startCheckmarkDrawing(index) {
    if (index < 0 || index >= TOTAL_ITEMS) return;
    if (drawingIndex === index) return;

    var item = checklistItemElements[index];
    if (item.classList.contains('completed')) return;
    if (item.classList.contains('drawing')) return;

    item.style.setProperty('--check-duration', CHECK_DRAW_DURATION_MS + 'ms');
    item.classList.add('drawing');
    drawingIndex = index;
  }

  function completeCheckmark(index) {
    if (index < 0 || index >= TOTAL_ITEMS) return;

    var item = checklistItemElements[index];
    item.classList.remove('drawing');
    item.classList.add('completed');

    if (drawingIndex === index) {
      drawingIndex = -1;
    }
  }

  function shouldStartDrawing() {
    var phaseInCycle = phase % Math.PI;
    var phaseUntilTick = Math.PI - phaseInCycle;
    return phaseUntilTick <= CHECK_START_PHASE_OFFSET && phaseUntilTick > 0;
  }

  // Typewriter effect - type out text character by character
  function startTypewriter(index) {
    if (index < 0 || index >= TOTAL_ITEMS) return;
    if (typingIndex === index) return;

    typingIndex = index;
    var item = checklistItemElements[index];
    var textEl = item.querySelector('.check-text');
    var fullText = CHECKLIST_ITEMS[index];
    var charIndex = 0;

    // Create cursor
    var cursor = document.createElement('span');
    cursor.className = 'typing-cursor';

    textEl.textContent = '';
    textEl.appendChild(cursor);

    var charDelay = TYPING_DURATION_MS / fullText.length;

    function typeNext() {
      if (charIndex < fullText.length) {
        // Update text, keep cursor at end
        textEl.textContent = fullText.substring(0, charIndex + 1);
        textEl.appendChild(cursor);
        charIndex++;
        setTimeout(typeNext, charDelay);
      } else {
        // Remove cursor when done
        if (cursor.parentNode) {
          cursor.parentNode.removeChild(cursor);
        }
      }
    }

    typeNext();
  }

  function createChecklistItems() {
    for (var i = 0; i < TOTAL_ITEMS; i++) {
      var li = document.createElement('li');
      li.className = 'checklist-item';
      li.setAttribute('data-index', i);

      var checkbox = document.createElement('span');
      checkbox.className = 'check-box';

      var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('class', 'check-svg');
      svg.setAttribute('viewBox', '0 0 24 24');

      var pathDown = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      pathDown.setAttribute('class', 'check-path-down');
      pathDown.setAttribute('d', 'M 2 11 L 8 18');

      var pathUp = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      pathUp.setAttribute('class', 'check-path-up');
      pathUp.setAttribute('d', 'M 8 18 L 22 4');

      svg.appendChild(pathDown);
      svg.appendChild(pathUp);
      checkbox.appendChild(svg);

      var text = document.createElement('span');
      text.className = 'check-text';
      // Items beyond initial viewport start empty (will type in)
      var initiallyVisible = VISIBLE_ITEMS;
      text.textContent = (i < initiallyVisible) ? CHECKLIST_ITEMS[i] : '';

      li.appendChild(checkbox);
      li.appendChild(text);
      checklistTrack.appendChild(li);
    }

    checklistItemElements = document.querySelectorAll('.checklist-item');
  }

  function initChecklistController() {
    document.addEventListener('metronome-tick', function() {
      if (activeIndex >= TOTAL_ITEMS) {
        return;
      }

      completeCheckmark(activeIndex);

      document.dispatchEvent(new CustomEvent('checklist-progress', {
        detail: { completed: activeIndex + 1, total: TOTAL_ITEMS }
      }));

      activeIndex++;

      // Trigger CALM transition after 6 ticks
      if (activeIndex === 6) {
        scheduleCalmTransition();
      }

      if (activeIndex >= TOTAL_ITEMS) {
        isComplete = true;
        updateClockDisplay(TOTAL_ITEMS);
        return;
      }

      // Type in the newest item appearing at bottom of list
      var bottomItemIndex = activeIndex + (VISIBLE_ITEMS - CENTER_INDEX - 1);
      if (bottomItemIndex < TOTAL_ITEMS) {
        startTypewriter(bottomItemIndex);
      }

      var scrollToCenter = (activeIndex - CENTER_INDEX) * ITEM_HEIGHT;

      if (scrollToCenter > targetScrollOffset) {
        targetScrollOffset = scrollToCenter;
      }
    });
  }

  function scheduleClockUpdateIfNeeded() {
    if (isComplete) {
      return;
    }

    ticksSinceLastClockUpdate++;

    if (ticksSinceLastClockUpdate >= nextClockUpdateThreshold) {
      var delay = randomInt(CLOCK_DELAY_MIN, CLOCK_DELAY_MAX);
      var targetCount = activeIndex;

      setTimeout(function() {
        updateClockDisplay(targetCount);
      }, delay);

      ticksSinceLastClockUpdate = 0;
      nextClockUpdateThreshold = randomInt(CLOCK_UPDATE_TICK_MIN, CLOCK_UPDATE_TICK_MAX);
    }
  }

  function formatTime(hours, minutes) {
    var h = hours % 24;
    var period;

    if (h >= 12 && h < 24) {
      period = 'PM';
    } else {
      period = 'AM';
    }

    if (h === 0) {
      h = 12;
    } else if (h > 12) {
      h = h - 12;
    }

    var m = minutes < 10 ? '0' + minutes : minutes;
    return h + ':' + m + ' ' + period;
  }

  function updateClockDisplay(completed) {
    if (clockCompletedCount >= TOTAL_ITEMS) {
      return;
    }

    clockCompletedCount = completed;
    var minutesElapsed = Math.round((clockCompletedCount / TOTAL_ITEMS) * TOTAL_MINUTES);
    var totalMinutes = START_HOUR * 60 + START_MINUTE + minutesElapsed;
    var hours = Math.floor(totalMinutes / 60);
    var minutes = totalMinutes % 60;
    timeIndicator.textContent = formatTime(hours, minutes);
  }

  function scheduleCalmTransition() {
    setTimeout(function() {
      timeIndicator.classList.add('fading');

      setTimeout(function() {
        timeIndicator.textContent = 'CALM';
        timeIndicator.classList.remove('fading');
        timeIndicator.classList.add('calm');
        timeIndicator.style.color = '';
      }, CALM_FADE_DURATION_MS);
    }, CALM_DELAY_MS);
  }

  var BG_COLOR_START = { r: 10, g: 11, b: 13 };
  var BG_COLOR_END = { r: 42, g: 43, b: 75 };

  function updateBackgroundColor(completed, total) {
    var progress = completed / total;
    // Background color transition disabled
    // var r = Math.round(lerp(BG_COLOR_START.r, BG_COLOR_END.r, progress));
    // var g = Math.round(lerp(BG_COLOR_START.g, BG_COLOR_END.g, progress));
    // var b = Math.round(lerp(BG_COLOR_START.b, BG_COLOR_END.b, progress));
    // background.style.backgroundColor = 'rgb(' + r + ',' + g + ',' + b + ')';

    // Fade spotlight as confidence increases
    if (spotlight) {
      spotlight.style.opacity = 1 - progress;
    }

    // Gradually transition metronome to silhouette
    silhouetteProgress = progress;
  }

  function initBackgroundController() {
    document.addEventListener('checklist-progress', function(e) {
      updateBackgroundColor(e.detail.completed, e.detail.total);
    });
  }

  // Dynamic font sizing - shrink only items that are too long
  function calcFontSizes() {
    var viewport = document.querySelector('.checklist-viewport');
    if (!viewport || !checklistItemElements || !checklistItemElements.length) return;

    var viewportWidth = viewport.offsetWidth;
    var padding = 50; // checkbox + gaps + padding
    var availWidth = viewportWidth - padding;

    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    var baseSize = 12;
    var minSize = 8;

    var textEls = document.querySelectorAll('.check-text');
    for (var i = 0; i < textEls.length; i++) {
      var text = CHECKLIST_ITEMS[i];
      ctx.font = baseSize + 'px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace';
      var textWidth = ctx.measureText(text).width;

      var fontSize = baseSize;
      if (textWidth > availWidth) {
        fontSize = Math.max(minSize, (availWidth / textWidth) * baseSize);
      }
      textEls[i].style.fontSize = fontSize + 'px';
    }
  }

  function init() {
    arm = document.querySelector('.metronome-arm');
    armWeight = document.querySelector('.metronome-weight');
    armPivot = document.querySelector('.metronome-pivot');
    metronomeBody = document.querySelector('.metronome-body');
    metronomeBase = document.querySelector('.metronome-base');
    metronomeScale = document.querySelector('.metronome-scale');
    scaleMarks = document.querySelectorAll('.scale-mark');
    headlinePulse = document.querySelector('.headline-pulse');
    checklistTrack = document.querySelector('.checklist-track');
    background = document.querySelector('.background');
    spotlight = document.querySelector('.spotlight');
    tickArea = document.querySelector('.tick-area');
    timeIndicator = document.querySelector('.time-indicator');
    headlineReveal = document.getElementById('headline-reveal');

    document.documentElement.style.setProperty('--item-height', ITEM_HEIGHT + 'px');

    createChecklistItems();
    calcFontSizes();
    window.addEventListener('resize', calcFontSizes);

    checklistTrack.style.transform = 'translateY(' + (-currentScrollOffset) + 'px)';

    initChecklistController();
    initBackgroundController();

    updateVisuals();

    // Reveal "On Purpose." after delay
    setTimeout(function() {
      if (headlineReveal) {
        headlineReveal.classList.add('visible');
      }
    }, REVEAL_DELAY_MS);

    requestAnimationFrame(animationLoop);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();

// Hero noise background
(function() {
  'use strict';

  var HERO_NOISE_PHRASES = [
    'deploy failed', 'rollback initiated', 'incident bridge open', 'who has access',
    'check the runbook', 'which runbook', 'page the on-call', 'they\'re on PTO',
    'escalate to platform', 'platform is underwater', 'we did this last month',
    'nobody documented it', 'the fix is a restart', 'why does restarting fix it',
    'don\'t touch that service', 'only Jake knows', 'Jake left', 'check Confluence',
    'Confluence is wrong', 'customer escalation', 'all hands on deck', 'war room',
    'same error different day', 'works on my machine', 'check the logs', 'which logs',
    'logging is broken', 'we\'ll fix it next sprint', 'added to backlog',
    'backlog is 400 items', 'priority 1', 'everything is priority 1', 'AWS is down',
    'it\'s not DNS', 'it was DNS', 'cert expired', 'who renewed the cert',
    'memory leak', 'disk full', 'connection pool exhausted', 'timeout', 'retry storm',
    'cascading failure', 'single point of failure', 'no rollback plan', 'redis is full',
    'kafka lag', 'OOM killed', 'zombie process', 'SSL handshake failed', 'rate limited',
    'quota exceeded', 'permissions denied', 'token expired', 'secret rotated',
    'config drift', 'missing env var', 'wrong branch', 'merge conflict'
  ];

  var heroNoiseSpans = [];
  var heroNoiseKilled = false;

  function killHeroNoise() {
    heroNoiseKilled = true;
  }

  window.killHeroNoise = killHeroNoise;

  function initHeroNoise() {
    var textEl = document.querySelector('.hero-noise-text');
    if (!textEl) return;

    // Fill with lots of phrases immediately
    var content = '';
    for (var i = 0; i < 500; i++) {
      var phrase = HERO_NOISE_PHRASES[i % HERO_NOISE_PHRASES.length];
      content += '<span class="phrase">' + phrase + '</span> â€¢ ';
    }
    textEl.innerHTML = content;

    heroNoiseSpans = textEl.querySelectorAll('.phrase');

    // Start highlight cycling
    startHeroHighlightCycle();
  }

  function startHeroHighlightCycle() {
    var activeCount = 0;
    var MAX_ACTIVE = 3;

    function highlightRandomPhrase() {
      if (heroNoiseKilled) return;
      if (heroNoiseSpans.length < 10) return;

      if (activeCount < MAX_ACTIVE) {
        var idx = Math.floor(Math.random() * heroNoiseSpans.length);
        var span = heroNoiseSpans[idx];

        if (!span.classList.contains('highlight')) {
          span.classList.add('highlight');
          activeCount++;

          var duration = 1200 + Math.random() * 800;
          setTimeout(function() {
            if (!heroNoiseKilled) {
              span.classList.remove('highlight');
            }
            activeCount--;
          }, duration);
        }
      }

      var nextDelay = 400 + Math.random() * 500;
      setTimeout(highlightRandomPhrase, nextDelay);
    }

    highlightRandomPhrase();
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initHeroNoise);
  } else {
    initHeroNoise();
  }
})();

// Subtext scroll expansion with flash
(function() {
  'use strict';

  var hasTriggered = false;

  function initSubtextExpansion() {
    var subtext = document.querySelector('.hero-subtext');
    var heroNoise = document.querySelector('.hero-noise');
    if (!subtext) return;

    // Scroll-based brightness
    function updateBrightness() {
      if (hasTriggered) return;

      var rect = subtext.getBoundingClientRect();
      var viewportHeight = window.innerHeight;

      // Calculate progress: 0 when at bottom of viewport, 1 when at center
      var elementCenter = rect.top + rect.height / 2;
      var progress = 1 - (elementCenter / viewportHeight);
      progress = Math.max(0, Math.min(1, progress * 1.5)); // Accelerate slightly

      // Interpolate from 0.08 to 1.0 opacity
      var opacity = 0.08 + (progress * 0.92);
      subtext.style.color = 'rgba(255, 255, 255, ' + opacity + ')';
    }

    window.addEventListener('scroll', updateBrightness, { passive: true });
    updateBrightness(); // Initial call

    var observer = new IntersectionObserver(function(entries) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting && !hasTriggered) {
          hasTriggered = true;

          // Expand the subtext - clear inline color so CSS takes over
          subtext.style.color = '';
          subtext.classList.add('expanded');

          // Fade in the opening blockquote during this animation
          var openingInner = document.querySelector('.opening-inner');
          if (openingInner) {
            openingInner.classList.add('visible');
          }

          // Signal that yellow banner is complete after shake animation (0.4s)
          setTimeout(function() {
            window.yellowBannerComplete = true;
            window.dispatchEvent(new CustomEvent('yellowBannerComplete'));
          }, 400);

          // Flash then stagger fade out all phrases
          if (heroNoise) {
            // Kill the highlight cycle
            if (window.killHeroNoise) {
              window.killHeroNoise();
            }

            // Flash and shake
            heroNoise.classList.add('flash');

            // After flash, stay bright then stagger fadeout
            setTimeout(function() {
              heroNoise.classList.remove('flash');
              heroNoise.classList.add('post-flash');

              var phrases = heroNoise.querySelectorAll('.phrase');
              var totalDuration = 6000; // 6 seconds total

              phrases.forEach(function(phrase) {
                var delay = Math.random() * totalDuration;
                setTimeout(function() {
                  phrase.classList.add('fade-out');
                }, delay);
              });
            }, 500);
          }

          observer.disconnect();
        }
      });
    }, {
      threshold: 0,
      rootMargin: '-50% 0px -50% 0px'
    });

    observer.observe(subtext);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initSubtextExpansion);
  } else {
    initSubtextExpansion();
  }
})();
  </script>
</div>
